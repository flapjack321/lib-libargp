From ff7e264a9a1c4e04783b7cb657fbe036b2e2c382 Mon Sep 17 00:00:00 2001
From: Ethan Cotterell <ethancotterell@gmail.com>
Date: Thu, 3 Jun 2021 09:37:58 +0100
Subject: [PATCH 4/8] patch: remove help dependency on _LIBC functions.
 included argp short name

---
 gnulib/gllib/argp-help.c | 235 ++++++++++++++++++++++-----------------
 1 file changed, 131 insertions(+), 104 deletions(-)

diff --git a/gnulib/gllib/argp-help.c b/gnulib/gllib/argp-help.c
index 02faa60..db9097c 100644
--- a/gnulib/gllib/argp-help.c
+++ b/gnulib/gllib/argp-help.c
@@ -34,19 +34,19 @@
 #include <stdarg.h>
 #include <ctype.h>
 #include <limits.h>
-#ifdef _LIBC
-# include <../libio/libioP.h>
-# include <wchar.h>
-#endif
-
-#ifdef _LIBC
-# include <libintl.h>
-# undef dgettext
-# define dgettext(domain, msgid) \
-   __dcgettext (domain, msgid, LC_MESSAGES)
-#else
+// #ifdef _LIBC
+// # include <../libio/libioP.h>
+// # include <wchar.h>
+// #endif
+
+// #ifdef _LIBC
+// # include <libintl.h>
+// # undef dgettext
+// # define dgettext(domain, msgid) \
+//    __dcgettext (domain, msgid, LC_MESSAGES)
+// #else
 # include "gettext.h"
-#endif
+// #endif
 
 #include "argp.h"
 #include "argp-fmtstream.h"
@@ -55,7 +55,8 @@
 #ifndef SIZE_MAX
 # define SIZE_MAX ((size_t) -1)
 #endif
-
+
+
 /* User-selectable (using an environment variable) formatting parameters.
 
    These may be specified in an environment variable called 'ARGP_HELP_FMT',
@@ -251,7 +252,8 @@ fill_in_uparams (const struct argp_state *state)
       validate_uparams (state, &new_params);
     }
 }
-
+
+
 /* Returns true if OPT hasn't been marked invisible.  Visibility only affects
    whether OPT is displayed or used in sorting, not option shadowing.  */
 #define ovisible(opt) (! ((opt)->flags & OPTION_HIDDEN))
@@ -270,7 +272,8 @@ fill_in_uparams (const struct argp_state *state)
 
 /* Returns true if OPT has a short option.  */
 #define oshort(opt) __option_is_short (opt)
-
+
+
 /*
    The help format for a particular option is like:
 
@@ -334,7 +337,8 @@ fill_in_uparams (const struct argp_state *state)
    unless you tell it not to with ARGP_NO_HELP.
 
 */
-
+
+
 /* Returns true if CH occurs between BEG and END.  */
 static int
 find_char (char ch, char *beg, char *end)
@@ -346,7 +350,8 @@ find_char (char ch, char *beg, char *end)
       beg++;
   return 0;
 }
-
+
+
 struct hol_cluster;             /* fwd decl */
 
 struct hol_entry
@@ -425,7 +430,8 @@ struct hol
   /* Clusters of entries in this hol.  */
   struct hol_cluster *clusters;
 };
-
+
+
 /* Create a struct hol from the options in ARGP.  CLUSTER is the
    hol_cluster in which these entries occur, or 0, if at the root.  */
 static struct hol *
@@ -497,7 +503,8 @@ make_hol (const struct argp *argp, struct hol_cluster *cluster)
 
   return hol;
 }
-
+
+
 /* Add a new cluster to HOL, with the given GROUP and HEADER (taken from the
    associated argp child list entry), INDEX, and PARENT, and return a pointer
    to it.  ARGP is the argp that this cluster results from.  */
@@ -521,7 +528,8 @@ hol_add_cluster (struct hol *hol, int group, const char *header, int index,
     }
   return cl;
 }
-
+
+
 /* Free HOL and any resources it uses.  */
 static void
 hol_free (struct hol *hol)
@@ -543,7 +551,8 @@ hol_free (struct hol *hol)
 
   free (hol);
 }
-
+
+
 static int
 hol_entry_short_iterate (const struct hol_entry *entry,
                          int (*func)(const struct argp_option *opt,
@@ -594,7 +603,8 @@ hol_entry_long_iterate (const struct hol_entry *entry,
 
   return val;
 }
-
+
+
 /* Iterator that returns true for the first short option.  */
 static int
 until_short (const struct argp_option *opt, const struct argp_option *real,
@@ -647,7 +657,8 @@ hol_find_entry (struct hol *hol, const char *name)
 
   return 0;
 }
-
+
+
 /* If an entry with the long option NAME occurs in HOL, set its special
    sort position to GROUP.  */
 static void
@@ -657,7 +668,8 @@ hol_set_group (struct hol *hol, const char *name, int group)
   if (entry)
     entry->group = group;
 }
-
+
+
 /* Order by group:  0, 1, 2, ..., n, -m, ..., -2, -1.
    EQ is what to return if GROUP1 and GROUP2 are the same.  */
 static int
@@ -710,7 +722,8 @@ hol_cluster_is_child (const struct hol_cluster *cl1,
     cl1 = cl1->parent;
   return cl1 == cl2;
 }
-
+
+
 /* Given the name of an OPTION_DOC option, modifies NAME to start at the tail
    that should be used for comparisons, and returns true iff it should be
    treated as a non-option.  */
@@ -829,7 +842,8 @@ hol_sort (struct hol *hol)
              hol_entry_qcmp);
     }
 }
-
+
+
 /* Append MORE to HOL, destroying MORE in the process.  Options in HOL shadow
    any in MORE with the same name.  */
 static void
@@ -923,7 +937,8 @@ hol_append (struct hol *hol, struct hol *more)
 
   hol_free (more);
 }
-
+
+
 /* Inserts enough spaces to make sure STREAM is at column COL.  */
 static void
 indent_to (argp_fmtstream_t stream, unsigned col)
@@ -962,7 +977,8 @@ arg (const struct argp_option *real, const char *req_fmt, const char *opt_fmt,
                                  dgettext (domain, real->arg));
     }
 }
-
+
+
 /* Helper functions for hol_entry_help.  */
 
 /* State used during the execution of hol_help.  */
@@ -1082,7 +1098,8 @@ comma (unsigned col, struct pentry_state *pest)
 
   indent_to (pest->stream, col);
 }
-
+
+
 /* Print help for ENTRY to STREAM.  */
 static void
 hol_entry_help (struct hol_entry *entry, const struct argp_state *state,
@@ -1209,7 +1226,8 @@ cleanup:
   __argp_fmtstream_set_lmargin (stream, old_lm);
   __argp_fmtstream_set_wmargin (stream, old_wm);
 }
-
+
+
 /* Output a long help message about the options in HOL to STREAM.  */
 static void
 hol_help (struct hol *hol, const struct argp_state *state,
@@ -1240,7 +1258,8 @@ optional for any corresponding short options.");
         free ((char *) fstr);
     }
 }
-
+
+
 /* Helper functions for hol_usage.  */
 
 /* If OPT is a short option without an arg, append its key to the string
@@ -1319,7 +1338,8 @@ usage_long_opt (const struct argp_option *opt,
 
   return 0;
 }
-
+
+
 /* Print a short usage description for the arguments in HOL to STREAM.  */
 static void
 hol_usage (struct hol *hol, argp_fmtstream_t stream)
@@ -1358,7 +1378,8 @@ hol_usage (struct hol *hol, argp_fmtstream_t stream)
                                 entry->argp->argp_domain, stream);
     }
 }
-
+
+
 /* Make a HOL containing all levels of options in ARGP.  CLUSTER is the
    cluster in which ARGP's entries should be clustered, or 0.  */
 static struct hol *
@@ -1381,7 +1402,8 @@ argp_hol (const struct argp *argp, struct hol_cluster *cluster)
       }
   return hol;
 }
-
+
+
 /* Calculate how many different levels with alternative args strings exist in
    ARGP.  */
 static size_t
@@ -1461,7 +1483,8 @@ argp_args_usage (const struct argp *argp, const struct argp_state *state,
 
   return !advance;
 }
-
+
+
 /* Print the documentation for ARGP to STREAM; if POST is false, then
    everything preceding a '\v' character in the documentation strings (or
    the whole string, for those with none) is printed, otherwise, everything
@@ -1554,7 +1577,8 @@ argp_doc (const struct argp *argp, const struct argp_state *state,
 
   return anything;
 }
-
+
+
 /* Output a usage message for ARGP to STREAM.  If called from
    argp_state_help, STATE is the relevant parsing state.  FLAGS are from the
    set ARGP_HELP_*.  NAME is what to use wherever a 'program name' is
@@ -1570,9 +1594,9 @@ _help (const struct argp *argp, const struct argp_state *state, FILE *stream,
   if (! stream)
     return;
 
-#if _LIBC || (HAVE_FLOCKFILE && HAVE_FUNLOCKFILE)
-  __flockfile (stream);
-#endif
+// #if _LIBC || (HAVE_FLOCKFILE && HAVE_FUNLOCKFILE)
+//   __flockfile (stream);
+// #endif
 
   if (! uparams.valid)
     fill_in_uparams (state);
@@ -1580,9 +1604,9 @@ _help (const struct argp *argp, const struct argp_state *state, FILE *stream,
   fs = __argp_make_fmtstream (stream, 0, uparams.rmargin, 0);
   if (! fs)
     {
-#if _LIBC || (HAVE_FLOCKFILE && HAVE_FUNLOCKFILE)
-      __funlockfile (stream);
-#endif
+// #if _LIBC || (HAVE_FLOCKFILE && HAVE_FUNLOCKFILE)
+//       __funlockfile (stream);
+// #endif
       return;
     }
 
@@ -1690,16 +1714,17 @@ Try '%s --help' or '%s --usage' for more information.\n"),
       anything = 1;
     }
 
-#if _LIBC || (HAVE_FLOCKFILE && HAVE_FUNLOCKFILE)
-  __funlockfile (stream);
-#endif
+// #if _LIBC || (HAVE_FLOCKFILE && HAVE_FUNLOCKFILE)
+//   __funlockfile (stream);
+// #endif
 
   if (hol)
     hol_free (hol);
 
   __argp_fmtstream_free (fs);
 }
-
+
+
 /* Output a usage message for ARGP to STREAM.  FLAGS are from the set
    ARGP_HELP_*.  NAME is what to use wherever a 'program name' is needed. */
 void __argp_help (const struct argp *argp, FILE *stream,
@@ -1711,14 +1736,14 @@ void __argp_help (const struct argp *argp, FILE *stream,
 weak_alias (__argp_help, argp_help)
 #endif
 
-#if ! (defined _LIBC || HAVE_DECL_PROGRAM_INVOCATION_SHORT_NAME)
+// #if ! (defined _LIBC || HAVE_DECL_PROGRAM_INVOCATION_SHORT_NAME)
 char *
 __argp_short_program_name (void)
 {
-# if HAVE_DECL_PROGRAM_INVOCATION_NAME
-  char *name = strrchr (program_invocation_name, '/');
-  return name ? name + 1 : program_invocation_name;
-# else
+// # if HAVE_DECL_PROGRAM_INVOCATION_NAME
+//   char *name = strrchr (program_invocation_name, '/');
+//   return name ? name + 1 : program_invocation_name;
+// # else
   /* FIXME: What now? Miles suggests that it is better to use NULL,
      but currently the value is passed on directly to fputs_unlocked,
      so that requires more changes. */
@@ -1726,9 +1751,9 @@ __argp_short_program_name (void)
 #  warning No reasonable value to return
 # endif /* __GNUC__ */
   return "";
-# endif
+// # endif
 }
-#endif
+// #endif
 
 /* Output, if appropriate, a usage message for STATE to STREAM.  FLAGS are
    from the set ARGP_HELP_*.  */
@@ -1755,7 +1780,8 @@ __argp_state_help (const struct argp_state *state, FILE *stream, unsigned flags)
 #ifdef weak_alias
 weak_alias (__argp_state_help, argp_state_help)
 #endif
-
+
+
 /* If appropriate, print the printf string FMT and following args, preceded
    by the program name and ':', to stderr, and followed by a "Try ... --help"
    message, then exit (1).  */
@@ -1770,23 +1796,23 @@ __argp_error (const struct argp_state *state, const char *fmt, ...)
         {
           va_list ap;
 
-#if _LIBC || (HAVE_FLOCKFILE && HAVE_FUNLOCKFILE)
-          __flockfile (stream);
-#endif
+// #if _LIBC || (HAVE_FLOCKFILE && HAVE_FUNLOCKFILE)
+//           __flockfile (stream);
+// #endif
 
           va_start (ap, fmt);
 
-#ifdef _LIBC
-          char *buf;
+// #ifdef _LIBC
+//           char *buf;
+//
+//           if (_IO_vasprintf (&buf, fmt, ap) < 0)
+//             buf = NULL;
 
-          if (_IO_vasprintf (&buf, fmt, ap) < 0)
-            buf = NULL;
+//           __fxprintf (stream, "%s: %s\n",
+//                       state ? state->name : __argp_short_program_name (), buf);
 
-          __fxprintf (stream, "%s: %s\n",
-                      state ? state->name : __argp_short_program_name (), buf);
-
-          free (buf);
-#else
+//           free (buf);
+// #else
           fputs_unlocked (state ? state->name : __argp_short_program_name (),
                           stream);
           putc_unlocked (':', stream);
@@ -1795,22 +1821,23 @@ __argp_error (const struct argp_state *state, const char *fmt, ...)
           vfprintf (stream, fmt, ap);
 
           putc_unlocked ('\n', stream);
-#endif
+// #endif
 
           __argp_state_help (state, stream, ARGP_HELP_STD_ERR);
 
           va_end (ap);
 
-#if _LIBC || (HAVE_FLOCKFILE && HAVE_FUNLOCKFILE)
-          __funlockfile (stream);
-#endif
+// #if _LIBC || (HAVE_FLOCKFILE && HAVE_FUNLOCKFILE)
+//           __funlockfile (stream);
+// #endif
         }
     }
 }
 #ifdef weak_alias
 weak_alias (__argp_error, argp_error)
 #endif
-
+
+
 /* Similar to the standard gnu error-reporting function error(), but will
    respect the ARGP_NO_EXIT and ARGP_NO_ERRS flags in STATE, and will print
    to STATE->err_stream.  This is useful for argument parsing code that is
@@ -1829,38 +1856,38 @@ __argp_failure (const struct argp_state *state, int status, int errnum,
 
       if (stream)
         {
-#if _LIBC || (HAVE_FLOCKFILE && HAVE_FUNLOCKFILE)
-          __flockfile (stream);
-#endif
-
-#ifdef _LIBC
-          __fxprintf (stream, "%s",
-                      state ? state->name : __argp_short_program_name ());
-#else
+// #if _LIBC || (HAVE_FLOCKFILE && HAVE_FUNLOCKFILE)
+//           __flockfile (stream);
+// #endif
+
+// #ifdef _LIBC
+//           __fxprintf (stream, "%s",
+//                       state ? state->name : __argp_short_program_name ());
+// #else
           fputs_unlocked (state ? state->name : __argp_short_program_name (),
                           stream);
-#endif
+// #endif
 
           if (fmt)
             {
               va_list ap;
 
               va_start (ap, fmt);
-#ifdef _LIBC
-              char *buf;
-
-              if (_IO_vasprintf (&buf, fmt, ap) < 0)
-                buf = NULL;
-
-              __fxprintf (stream, ": %s", buf);
-
-              free (buf);
-#else
+// #ifdef _LIBC
+//              char *buf;
+//
+//               if (_IO_vasprintf (&buf, fmt, ap) < 0)
+//                 buf = NULL;
+//
+//               __fxprintf (stream, ": %s", buf);
+//
+//               free (buf);
+// #else
               putc_unlocked (':', stream);
               putc_unlocked (' ', stream);
 
               vfprintf (stream, fmt, ap);
-#endif
+// #endif
 
               va_end (ap);
             }
@@ -1869,10 +1896,10 @@ __argp_failure (const struct argp_state *state, int status, int errnum,
             {
               char buf[200];
 
-#ifdef _LIBC
-              __fxprintf (stream, ": %s",
-                          __strerror_r (errnum, buf, sizeof (buf)));
-#else
+// #ifdef _LIBC
+//              __fxprintf (stream, ": %s",
+//                          __strerror_r (errnum, buf, sizeof (buf)));
+// #else
               char const *s = NULL;
               putc_unlocked (':', stream);
               putc_unlocked (' ', stream);
@@ -1888,19 +1915,19 @@ __argp_failure (const struct argp_state *state, int status, int errnum,
                 s = dgettext (state->root_argp->argp_domain,
                               "Unknown system error");
               fputs_unlocked (s, stream);
-#endif
+// #endif
             }
 
-#if _LIBC
-          if (_IO_fwide (stream, 0) > 0)
-            putwc_unlocked (L'\n', stream);
-          else
-#endif
+// #if _LIBC
+//           if (_IO_fwide (stream, 0) > 0)
+//             putwc_unlocked (L'\n', stream);
+//           else
+// #endif
             putc_unlocked ('\n', stream);
 
-#if _LIBC || (HAVE_FLOCKFILE && HAVE_FUNLOCKFILE)
-          __funlockfile (stream);
-#endif
+// #if _LIBC || (HAVE_FLOCKFILE && HAVE_FUNLOCKFILE)
+//           __funlockfile (stream);
+// #endif
 
           if (status && (!state || !(state->flags & ARGP_NO_EXIT)))
             exit (status);
-- 
2.25.1

